// ***DO NOT EDIT THIS FILE - IT IS AUTOMATICALLY GENERATED BY CMAKE***

#include <osgEarth/Shaders>

namespace osgEarth
{
    Shaders::Shaders()
    {
        // AlphaEffect
        AlphaEffectFragment = "AlphaEffect.frag.glsl";
        _sources[AlphaEffectFragment] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_alphaEffect_frag%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.5%EOL%%EOL%uniform float oe_alphaEffect_alpha;%EOL%%EOL%void oe_alphaEffect_frag(inout vec4 color)%EOL%{%EOL%    color = color * oe_alphaEffect_alpha;%EOL%}%EOL%%EOL%";


        // Depth Offset
        DepthOffsetVertex = "DepthOffset.vert.glsl";
       _sources[DepthOffsetVertex] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_depthOffset_vertex%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.8%EOL%%EOL%uniform float oe_depthOffset_minBias;%EOL%uniform float oe_depthOffset_maxBias;%EOL%uniform float oe_depthOffset_minRange;%EOL%uniform float oe_depthOffset_maxRange;%EOL%%EOL%void oe_depthOffset_vertex(inout vec4 vertexView)%EOL%{%EOL%    // calculate range to target:%EOL%    float range = length(vertexView.xyz);%EOL%%EOL%    // calculate the depth offset bias for this range:%EOL%    float ratio = (clamp(range, oe_depthOffset_minRange, oe_depthOffset_maxRange)-oe_depthOffset_minRange)/(oe_depthOffset_maxRange-oe_depthOffset_minRange);%EOL%    float bias = oe_depthOffset_minBias + ratio * (oe_depthOffset_maxBias-oe_depthOffset_minBias);%EOL%%EOL%	// clamp the bias to 1/2 of the range of the vertex. We don't want to %EOL%    // pull the vertex TOO close to the camera and certainly not behind it.%EOL%    bias = min(bias, range*0.5);%EOL%%EOL%    //   pull the vertex towards the camera.%EOL%    vec3 pullVec = normalize(vertexView.xyz);%EOL%    vec3 simVert3 = vertexView.xyz - pullVec*bias;%EOL%    vertexView = vec4(simVert3, 1.0);%EOL%}%EOL%";


       // Draping
       DrapingVertex = "Draping.vert.glsl";
       _sources[DrapingVertex] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_overlay_vertex%EOL%#pragma vp_location   vertex_view%EOL%%EOL%uniform mat4 oe_overlay_texmatrix;%EOL%uniform float oe_overlay_rttLimitZ;%EOL%%EOL%out vec4 oe_overlay_texcoord;%EOL%%EOL%void oe_overlay_vertex(inout vec4 vertexVIEW)%EOL%{%EOL%    oe_overlay_texcoord = oe_overlay_texmatrix * vertexVIEW;%EOL%}%EOL%";

       DrapingFragment = "Draping.frag.glsl";
       _sources[DrapingFragment] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_overlay_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.6%EOL%%EOL%uniform bool oe_isPickCamera;%EOL%uniform sampler2D oe_overlay_tex;%EOL%in vec4 oe_overlay_texcoord;%EOL%%EOL%void oe_overlay_fragment(inout vec4 color)%EOL%{%EOL%    vec4 texel = texture2DProj(oe_overlay_tex, oe_overlay_texcoord);%EOL%    vec4 blendedTexel = vec4( mix( color.rgb, texel.rgb, texel.a ), color.a);%EOL%%EOL%    float pick = oe_isPickCamera? 1.0 : 0.0;%EOL%    color = mix(blendedTexel, texel, pick);%EOL%}%EOL%%EOL%";


        // GPU Clamping
        GPUClampingVertex = "GPUClamping.vert.glsl";
        _sources[GPUClampingVertex] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_clamp_vertex%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%%EOL%#pragma include GPUClamping.vert.lib.glsl%EOL%%EOL%in vec4 oe_clamp_attrs;     // vertex attribute%EOL%in float oe_clamp_height;   // vertex attribute%EOL%%EOL%out float oe_clamp_alpha;%EOL%%EOL%uniform bool oe_clamp_hasAttrs;%EOL%uniform bool oe_isGeocentric;%EOL%uniform float oe_clamp_altitudeOffset;%EOL%uniform float oe_clamp_horizonDistance2;%EOL%%EOL%void oe_clamp_vertex(inout vec4 vertexView)%EOL%{%EOL%    const float ClampToAnchor = 1.0;%EOL%%EOL%    // check distance; alpha out if its beyone the horizon distance.%EOL%    oe_clamp_alpha = oe_isGeocentric ? %EOL%        clamp(oe_clamp_horizonDistance2 - (vertexView.z*vertexView.z), 0.0, 1.0) :%EOL%        1.0;%EOL%%EOL%    // if visible, calculate clamping.%EOL%    // note: no branch divergence in the vertex shader%EOL%    if ( oe_clamp_alpha > 0.0 )%EOL%    {%EOL%        bool relativeToAnchor = oe_clamp_hasAttrs && (oe_clamp_attrs.a == ClampToAnchor);%EOL%%EOL%        float verticalOffset = oe_clamp_hasAttrs ? oe_clamp_attrs.z : 0.0;%EOL%%EOL%        // if we are using the anchor point, xform it into view space to prepare%EOL%        // for clamping. Force Z=0 for anchoring.%EOL%        vec4 pointToClamp = relativeToAnchor?%EOL%            gl_ModelViewMatrix * vec4(oe_clamp_attrs.xy, 0.0, 1.0) :%EOL%            vertexView;%EOL%%EOL%        // find the clamped point.%EOL%        vec4  clampedPoint;%EOL%        float depth;%EOL%        oe_getClampedViewVertex(pointToClamp, clampedPoint, depth);%EOL%%EOL%        float dh = verticalOffset + oe_clamp_altitudeOffset;%EOL%%EOL%        if ( relativeToAnchor )%EOL%        {%EOL%            // if we are clamping relative to the anchor point, adjust the HAT based on the%EOL%            // distance from the anchor point to the terrain. Since distance() is unsigned,%EOL%            // we use the vector dot product to calculate whether to adjust up or down.%EOL%            float dist = distance(pointToClamp, clampedPoint);%EOL%            float dir  = sign(dot(clampedPoint-pointToClamp, vertexView-pointToClamp));%EOL%            dh += (dist * dir);%EOL%        }%EOL%        else%EOL%        {%EOL%            // if we are clamping to the terrain, the vertex becomes the%EOL%            // clamped point%EOL%            vertexView.xyz = clampedPoint.xyz;%EOL%            dh += oe_clamp_height;%EOL%        }%EOL%        %EOL%        // calculate the up vector along which clamping will occur (in either direction)%EOL%        vec3 up;%EOL%        oe_getClampingUpVector( up );%EOL%        vertexView.xyz += up*dh;%EOL%%EOL%        // if the clamped depth value is near the far plane, suppress drawing%EOL%        // to avoid rendering anomalies.%EOL%        oe_clamp_alpha = 1.0-step(0.9999, depth);%EOL%    }%EOL%}%EOL%%EOL%";

        GPUClampingFragment = "GPUClamping.frag.glsl";
        _sources[GPUClampingFragment] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_clamp_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%%EOL%in float oe_clamp_alpha;%EOL%%EOL%void oe_clamp_fragment(inout vec4 color)%EOL%{%EOL%    // adjust the alpha component to %QUOTE%hide%QUOTE% geometry beyond the visible horizon.%EOL%    color.a *= oe_clamp_alpha;%EOL%}%EOL%";

        GPUClampingVertexLib = "GPUClamping.vert.lib.glsl";
        _sources[GPUClampingVertexLib] = "// note: this is an include file%EOL%%EOL%// depth texture captures by the clamping technique%EOL%uniform sampler2D oe_clamp_depthTex;%EOL%%EOL%// matrix transforming from view space to depth-texture clip space%EOL%uniform mat4 oe_clamp_cameraView2depthClip;%EOL%%EOL%// matrix transform from depth-tecture clip space to view space%EOL%uniform mat4 oe_clamp_depthClip2cameraView;%EOL%%EOL%// Given a vertex in view space, clamp it to the %QUOTE%ground%QUOTE% as represented%EOL%// by an orthographic depth texture. Return the clamped vertex in view space,%EOL%// along with the associated depth value.%EOL%void oe_getClampedViewVertex(in vec4 vertView, out vec4 out_clampedVertView, out float out_depth)%EOL%{%EOL%    // transform the vertex into the depth texture's clip coordinates.%EOL%    vec4 vertDepthClip = oe_clamp_cameraView2depthClip * vertView;%EOL%%EOL%    // sample the depth map%EOL%    out_depth = texture2DProj( oe_clamp_depthTex, vertDepthClip ).r;%EOL%%EOL%    // now transform into depth-view space so we can apply the height-above-ground:%EOL%    vec4 clampedVertDepthClip = vec4(vertDepthClip.x, vertDepthClip.y, out_depth, 1.0);%EOL%%EOL%    // convert back into view space.%EOL%    out_clampedVertView = oe_clamp_depthClip2cameraView * clampedVertDepthClip;%EOL%}%EOL%%EOL%// Returns a vector indicating the %QUOTE%down%QUOTE% direction.%EOL%void oe_getClampingUpVector(out vec3 up)%EOL%{%EOL%    up = normalize(mat3(oe_clamp_depthClip2cameraView) * vec3(0,0,-1));%EOL%}%EOL%%EOL%";


        // DrawInstanced
        InstancingVertex = "Instancing.vert.glsl";
        _sources[InstancingVertex] = "#version $GLSL_VERSION_STR%EOL%#extension GL_EXT_gpu_shader4 : enable%EOL%#extension GL_ARB_draw_instanced: enable%EOL%%EOL%#pragma vp_entryPoint oe_di_setInstancePosition%EOL%#pragma vp_location   vertex_model%EOL%#pragma vp_order      0.0%EOL%%EOL%uniform samplerBuffer oe_di_postex_TBO;%EOL%%EOL%// Stage-global containing object ID%EOL%uint oe_index_objectid;%EOL%vec3 vp_Normal;%EOL%%EOL%void oe_di_setInstancePosition(inout vec4 VertexMODEL)%EOL%{ %EOL%    int index = 4 * gl_InstanceID;%EOL%%EOL%    vec4 m0 = texelFetch(oe_di_postex_TBO, index);%EOL%    vec4 m1 = texelFetch(oe_di_postex_TBO, index+1); %EOL%    vec4 m2 = texelFetch(oe_di_postex_TBO, index+2); %EOL%    vec4 m3 = texelFetch(oe_di_postex_TBO, index+3);%EOL%%EOL%    // decode the ObjectID from the last column:%EOL%    %EOL%    oe_index_objectid = uint(m3[0]) + (uint(m3[1]) << 8u) + (uint(m3[2]) << 16u) + (uint(m3[3]) << 24u);%EOL%    %EOL%    // rebuild positioning matrix and transform the vert. (Note, the matrix is actually%EOL%    // transposed so we have to reverse the multiplication order.)%EOL%    mat4 xform = mat4(m0, m1, m2, vec4(0,0,0,1));%EOL%%EOL%    VertexMODEL = VertexMODEL * xform;%EOL%%EOL%    // rotate the normal vector in the same manner.%EOL%    vp_Normal = vp_Normal * mat3(xform);%EOL%}%EOL%%EOL%%EOL%";
    }
};
