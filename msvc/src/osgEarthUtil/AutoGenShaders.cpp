// ***DO NOT EDIT THIS FILE - IT IS AUTOMATICALLY GENERATED BY CMAKE***

#include <osgEarthUtil/Shaders>

using namespace osgEarth::Util;

Shaders::Shaders()
{
    ContourMap_Vertex = "ContourMap.vert.glsl";
    _sources[ContourMap_Vertex] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%    // NOTE: This vertex shader is no longer used.%EOL%%EOL%#pragma vp_entryPoint oe_contour_vertex%EOL%#pragma vp_location   vertex_model%EOL%#pragma vp_order      0.5%EOL%%EOL%varying vec4 oe_layer_tilec;%EOL%uniform float oe_contour_min;%EOL%uniform float oe_contour_range;%EOL%varying float oe_contour_lookup;%EOL%%EOL%float oe_terrain_getElevation(in vec2 uv);%EOL%%EOL%void oe_contour_vertex(inout vec4 VertexModel)%EOL%{%EOL%    float height = oe_terrain_getElevation(oe_layer_tilec.st);%EOL%    float height_normalized = (height-oe_contour_min)/oe_contour_range;%EOL%    oe_contour_lookup = clamp( height_normalized, 0.0, 1.0 );%EOL%}%EOL%";

    ContourMap_Fragment = "ContourMap.frag.glsl";
    _sources[ContourMap_Fragment] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_contour_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.2%EOL%%EOL%varying vec4 oe_layer_tilec;%EOL%uniform sampler1D oe_contour_xfer;%EOL%uniform float oe_contour_opacity;%EOL%uniform float oe_contour_min;%EOL%uniform float oe_contour_range;%EOL%%EOL%float oe_terrain_getElevation(in vec2 uv);%EOL%%EOL%void oe_contour_fragment( inout vec4 color )%EOL%{%EOL%    float height = oe_terrain_getElevation(oe_layer_tilec.st);%EOL%    float height_normalized = (height-oe_contour_min)/oe_contour_range;%EOL%    float lookup = clamp( height_normalized, 0.0, 1.0 );%EOL%    vec4 texel = texture1D( oe_contour_xfer, lookup );%EOL%    color.rgb = mix(color.rgb, texel.rgb, texel.a * oe_contour_opacity);%EOL%}%EOL%";

    Fog_Vertex = "Fog.vert.glsl";
    _sources[Fog_Vertex] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_fog_vertex%EOL%#pragma vp_location   vertex_view%EOL%%EOL%uniform int oe_fog_algo;%EOL%%EOL%varying float oe_fogFactor;%EOL%%EOL%void oe_fog_vertex(inout vec4 vertexVIEW)%EOL%{%EOL%    float z = length( vertexVIEW.xyz );%EOL%%EOL%	// linear fog%EOL%	if (oe_fog_algo == 0)%EOL%	{%EOL%	  oe_fogFactor = clamp((gl_Fog.end - z) / (gl_Fog.end - gl_Fog.start), 0.0, 1.0);%EOL%	}%EOL%	// exp fog%EOL%	else if (oe_fog_algo == 1)%EOL%	{	%EOL%	  oe_fogFactor = clamp(exp( -gl_Fog.density * z ), 0.0, 1.0);%EOL%	}	%EOL%	else%EOL%	// exp2 fog%EOL%	{%EOL%        const float LOG2 = 1.442695;%EOL%        oe_fogFactor = clamp(exp2( -gl_Fog.density * gl_Fog.density * z * z * LOG2 ), 0.0, 1.0);%EOL%	}	%EOL%}%EOL%";

    Fog_Fragment = "Fog.frag.glsl";
    _sources[Fog_Fragment] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_fog_frag%EOL%#pragma vp_location   fragment_lighting%EOL%#pragma vp_order      1.1%EOL%%EOL%varying float oe_fogFactor;%EOL%%EOL%void oe_fog_frag(inout vec4 color)%EOL%{        %EOL%    color.rgb = mix( gl_Fog.color.rgb, color.rgb, oe_fogFactor);%EOL%}%EOL%";

    LogDepthBuffer_VertFile = "LogDepthBuffer.vert.glsl";
    _sources[LogDepthBuffer_VertFile] = "#version 110%EOL%%EOL%#pragma vp_entryPoint oe_logDepth_vert%EOL%#pragma vp_location   vertex_clip%EOL%#pragma vp_order      0.99%EOL%%EOL%uniform float oe_logDepth_FC;%EOL%varying float oe_logDepth_clipz;%EOL%%EOL%void oe_logDepth_vert(inout vec4 clip)%EOL%{%EOL%    if ( oe_logDepth_FC > 0.0 )%EOL%    {%EOL%        clip.z = (log2(max(1e-6, 1.0 + clip.w)) * oe_logDepth_FC - 1.0) * clip.w;%EOL%        oe_logDepth_clipz = 1.0 + clip.w;%EOL%    }%EOL%}%EOL%%EOL%";

    LogDepthBuffer_FragFile = "LogDepthBuffer.frag.glsl";
    _sources[LogDepthBuffer_FragFile] = "#version 110%EOL%%EOL%#pragma vp_entryPoint oe_logDepth_frag%EOL%#pragma vp_location   fragment_lighting%EOL%#pragma vp_order      0.99%EOL%%EOL%uniform float oe_logDepth_FC;%EOL%varying float oe_logDepth_clipz;%EOL%%EOL%void oe_logDepth_frag(inout vec4 color)%EOL%{%EOL%    if ( oe_logDepth_FC > 0.0 )%EOL%    {%EOL%        gl_FragDepth = log2(oe_logDepth_clipz) * 0.5*oe_logDepth_FC;%EOL%    }%EOL%}%EOL%%EOL%";

    LogDepthBuffer_VertOnly_VertFile = "LogDepthBuffer.VertOnly.vert.glsl";
    _sources[LogDepthBuffer_VertOnly_VertFile] = "#version 110%EOL%%EOL%#pragma vp_entryPoint oe_logDepth_vert%EOL%#pragma vp_location   vertex_clip%EOL%#pragma vp_order      0.99%EOL%%EOL%uniform float oe_logDepth_FC;%EOL%%EOL%void oe_logDepth_vert(inout vec4 clip)%EOL%{%EOL%    if ( oe_logDepth_FC > 0.0 )%EOL%    {%EOL%        clip.z = (log2(max(1e-6, clip.w+1.0))*oe_logDepth_FC - 1.0) * clip.w;%EOL%    }%EOL%}%EOL%%EOL%";

    Graticule_Fragment = "Graticule.frag.glsl";
    _sources[Graticule_Fragment] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_graticule_fragment%EOL%#pragma vp_location   fragment_lighting%EOL%#pragma vp_order      1.1%EOL%%EOL%uniform float oe_graticule_lineWidth;%EOL%uniform float oe_graticule_resolution;%EOL%uniform vec4  oe_graticule_color;%EOL%uniform mat4 osg_ViewMatrixInverse;%EOL%%EOL%in vec2 oe_graticule_coord;%EOL%%EOL%void oe_graticule_fragment(inout vec4 color)%EOL%{%EOL%    // double the effective res for longitude since it has twice the span%EOL%    vec2 gr = vec2(0.5*oe_graticule_resolution, oe_graticule_resolution);%EOL%    vec2 distanceToLine = mod(oe_graticule_coord, gr);%EOL%    vec2 dx = abs(dFdx(oe_graticule_coord));%EOL%    vec2 dy = abs(dFdy(oe_graticule_coord));%EOL%    vec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * oe_graticule_lineWidth;%EOL%%EOL%    if ( any(lessThan(distanceToLine, dF)))%EOL%    {%EOL%        // calculate some anti-aliasing%EOL%        vec2 f = distanceToLine/dF;%EOL%        float antialias = 1.0 - 2.0*abs(0.5 - min(f.x,f.y));%EOL%%EOL%        // Fade out the lines as you get closer to the ground.%EOL%        vec3 eye = osg_ViewMatrixInverse[3].xyz;%EOL%        float hae = length(eye) - 6378137.0;%EOL%        float maxHAE = 2000.0;%EOL%        float alpha = clamp(hae / maxHAE, 0.0, 1.0) * antialias;%EOL%        color.rgb = mix(color.rgb, oe_graticule_color.rgb, oe_graticule_color.a * alpha);%EOL%    }%EOL%}%EOL%";

    Graticule_Vertex = "Graticule.vert.glsl";
    _sources[Graticule_Vertex] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_graticule_vertex%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%%EOL%uniform vec4 oe_tile_key;%EOL%out vec4 oe_layer_tilec;%EOL%out vec2 oe_graticule_coord;%EOL%%EOL%%EOL%void oe_graticule_vertex(inout vec4 vertex)%EOL%{%EOL%    // calculate long and lat from [0..1] across the profile:%EOL%    vec2 r = (oe_tile_key.xy + oe_layer_tilec.xy)/exp2(oe_tile_key.z);%EOL%    oe_graticule_coord = vec2(0.5*r.x, r.y);%EOL%}%EOL%%EOL%";

    Shadowing_Vertex = "Shadowing.vert.glsl";
    _sources[Shadowing_Vertex] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_name       Shadowing Vertex Shader%EOL%#pragma vp_entryPoint oe_shadow_vertex%EOL%#pragma vp_location   vertex_view%EOL%%EOL%%EOL%uniform mat4 oe_shadow_matrix[$OE_SHADOW_NUM_SLICES];%EOL%%EOL%out vec4 oe_shadow_coord[$OE_SHADOW_NUM_SLICES];%EOL%%EOL%void oe_shadow_vertex(inout vec4 VertexVIEW)%EOL%{%EOL%    for(int i=0; i < $OE_SHADOW_NUM_SLICES; ++i)%EOL%    {%EOL%        oe_shadow_coord[i] = oe_shadow_matrix[i] * VertexVIEW;%EOL%    }%EOL%}%EOL%%EOL%";

    Shadowing_Fragment = "Shadowing.frag.glsl";
    _sources[Shadowing_Fragment] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_name       Shadowing Fragment Shader%EOL%#pragma vp_entryPoint oe_shadow_fragment%EOL%#pragma vp_location   fragment_lighting%EOL%#pragma vp_order      0.9%EOL%%EOL%uniform sampler2DArray oe_shadow_map;%EOL%uniform float          oe_shadow_color;%EOL%uniform float          oe_shadow_blur;%EOL%%EOL%in vec3 vp_Normal; // stage global%EOL%in vec4 oe_shadow_coord[$OE_SHADOW_NUM_SLICES];%EOL%%EOL%%EOL%#define OE_SHADOW_NUM_SAMPLES 16%EOL%%EOL%const vec2 oe_shadow_samples[16] = vec2[](%EOL%    vec2( -0.942016, -0.399062 ), vec2( 0.945586, -0.768907 ), vec2( -0.094184, -0.929389 ), vec2( 0.344959, 0.293878 ),%EOL%    vec2( -0.915886, 0.457714 ), vec2( -0.815442, -0.879125 ), vec2( -0.382775, 0.276768 ), vec2( 0.974844, 0.756484 ),%EOL%    vec2( 0.443233, -0.975116 ), vec2( 0.53743, -0.473734 ), vec2( -0.264969, -0.41893 ), vec2( 0.791975, 0.190909 ),%EOL%    vec2( -0.241888, 0.997065 ), vec2( -0.8141, 0.914376 ), vec2( 0.199841, 0.786414 ), vec2( 0.143832, -0.141008 )%EOL%);%EOL%%EOL%float oe_shadow_rand(vec2 co)%EOL%{%EOL%   return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);%EOL%}%EOL%%EOL%vec2 oe_shadow_rot(vec2 p, float a)%EOL%{%EOL%    vec2 sincos = vec2(sin(a), cos(a));%EOL%    return vec2(dot(p, vec2(sincos.y, -sincos.x)), dot(p, sincos.xy));%EOL%}%EOL%%EOL%// slow PCF sampling.%EOL%float oe_shadow_multisample(in vec3 c, in float refvalue, in float blur)%EOL%{%EOL%    float shadowed = 0.0;%EOL%    float randomAngle = 6.283185 * oe_shadow_rand(c.xy);%EOL%    for(int i=0; i<OE_SHADOW_NUM_SAMPLES; ++i)%EOL%    {%EOL%        vec2 off = oe_shadow_rot(oe_shadow_samples[i], randomAngle);%EOL%        vec3 pc = vec3(c.xy + off*blur, c.z);%EOL%        float depth = texture(oe_shadow_map, pc).r;%EOL%        %EOL%        if (depth < 1.0 && depth < refvalue )%EOL%        {%EOL%           shadowed += 1.0;%EOL%        }%EOL%    }%EOL%    return 1.0-(shadowed/OE_SHADOW_NUM_SAMPLES);%EOL%}%EOL%%EOL%void oe_shadow_fragment(inout vec4 color)%EOL%{%EOL%    float alpha = color.a;%EOL%    float factor = 1.0;%EOL%%EOL%    // pre-pixel biasing to reduce moire/acne%EOL%    const float b0 = 0.001;%EOL%    const float b1 = 0.01;%EOL%    vec3 L = normalize(gl_LightSource[0].position.xyz);%EOL%    vec3 N = normalize(vp_Normal);%EOL%    float costheta = clamp(dot(L,N), 0.0, 1.0);%EOL%    float bias = b0*tan(acos(costheta));%EOL%%EOL%    float depth;%EOL%%EOL%    // loop over the slices:%EOL%    for(int i=0; i<$OE_SHADOW_NUM_SLICES && factor > 0.0; ++i)%EOL%    {%EOL%        vec4 c = oe_shadow_coord[i];%EOL%        vec3 coord = vec3(c.x, c.y, float(i));%EOL%%EOL%        // TODO: This causes an NVIDIA error (DUI_foreachId) - disable for now.%EOL%        if ( oe_shadow_blur > 0.0 )%EOL%        {%EOL%            factor = min(factor, oe_shadow_multisample(coord, c.z-bias, oe_shadow_blur));%EOL%        }%EOL%        else%EOL%        {%EOL%            //float depth = texture(oe_shadow_map, coord).r;%EOL%            depth = texture(oe_shadow_map, coord).r;%EOL%            if ( depth < 1.0 && depth < c.z-bias )%EOL%                factor = 0.0;%EOL%        }%EOL%    }%EOL%%EOL%    vec3 colorInFullShadow = color.rgb * oe_shadow_color;%EOL%    color = vec4( mix(colorInFullShadow, color.rgb, factor), alpha );%EOL%%EOL%    //color = vec4(factor, 1.0);%EOL%}%EOL%%EOL%";
}
