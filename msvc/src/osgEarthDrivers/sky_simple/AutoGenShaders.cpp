// ***DO NOT EDIT THIS FILE - IT IS AUTOMATICALLY GENERATED BY CMAKE***

#include <osgEarthDrivers/sky_simple/SimpleSkyShaders>


using namespace osgEarth::SimpleSky;

Shaders::Shaders()
{
    Atmosphere_Vert = "SimpleSky.Atmosphere.vert.glsl";
    _sources[Atmosphere_Vert] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint atmos_vertex_main%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%%EOL%// Atmospheric Scattering and Sun Shaders%EOL%// Adapted from code that is Copyright (c) 2004 Sean ONeil%EOL%%EOL%uniform mat4 osg_ViewMatrixInverse;   // camera position in [3].xyz%EOL%uniform vec3 atmos_v3LightDir;        // The direction vector to the light source %EOL%uniform vec3 atmos_v3InvWavelength;   // 1 / pow(wavelength,4) for the rgb channels %EOL%uniform float atmos_fOuterRadius;     // Outer atmosphere radius %EOL%uniform float atmos_fOuterRadius2;    // fOuterRadius^2 		%EOL%uniform float atmos_fInnerRadius;     // Inner planetary radius %EOL%uniform float atmos_fInnerRadius2;    // fInnerRadius^2 %EOL%uniform float atmos_fKrESun;          // Kr * ESun 	%EOL%uniform float atmos_fKmESun;          // Km * ESun 		%EOL%uniform float atmos_fKr4PI;           // Kr * 4 * PI 	%EOL%uniform float atmos_fKm4PI;           // Km * 4 * PI 		%EOL%uniform float atmos_fScale;           // 1 / (fOuterRadius - fInnerRadius) 	%EOL%uniform float atmos_fScaleDepth;      // The scale depth %EOL%uniform float atmos_fScaleOverScaleDepth;     // fScale / fScaleDepth 	%EOL%uniform int atmos_nSamples; 	%EOL%uniform float atmos_fSamples; 				%EOL%%EOL%varying vec3 atmos_v3Direction; %EOL%varying vec3 atmos_mieColor; %EOL%varying vec3 atmos_rayleighColor; %EOL%%EOL%vec3 vVec; %EOL%float atmos_fCameraHeight;    // The camera's current height 		%EOL%float atmos_fCameraHeight2;   // fCameraHeight^2 %EOL%%EOL%float atmos_fastpow(in float x, in float y) %EOL%{ %EOL%    return x/(x+y-y*x); %EOL%} %EOL%%EOL%float atmos_scale(float fCos) 	%EOL%{ %EOL%    float x = 1.0 - fCos; %EOL%    return atmos_fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25)))); %EOL%} %EOL%%EOL%void atmos_SkyFromSpace(void) %EOL%{ %EOL%    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere) %EOL%    vec3 v3Pos = gl_Vertex.xyz; %EOL%    vec3 v3Ray = v3Pos - vVec; %EOL%    float fFar = length(v3Ray); %EOL%    v3Ray /= fFar; %EOL%%EOL%    // Calculate the closest intersection of the ray with the outer atmosphere %EOL%    // (which is the near point of the ray passing through the atmosphere) %EOL%    float B = 2.0 * dot(vVec, v3Ray); %EOL%    float C = atmos_fCameraHeight2 - atmos_fOuterRadius2; %EOL%    float fDet = max(0.0, B*B - 4.0 * C); 	%EOL%    float fNear = 0.5 * (-B - sqrt(fDet)); 		%EOL%%EOL%    // Calculate the ray's starting position, then calculate its scattering offset %EOL%    vec3 v3Start = vVec + v3Ray * fNear; 			%EOL%    fFar -= fNear; 	%EOL%    float fStartAngle = dot(v3Ray, v3Start) / atmos_fOuterRadius; 			%EOL%    float fStartDepth = exp(-1.0 / atmos_fScaleDepth); %EOL%    float fStartOffset = fStartDepth*atmos_scale(fStartAngle); 		%EOL%%EOL%    // Initialize the atmos_ing loop variables 	%EOL%    float fSampleLength = fFar / atmos_fSamples; 		%EOL%    float fScaledLength = fSampleLength * atmos_fScale; 					%EOL%    vec3 v3SampleRay = v3Ray * fSampleLength; 	%EOL%    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5; 	%EOL%%EOL%    // Now loop through the sample rays %EOL%    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); %EOL%    vec3 v3Attenuate;   %EOL%    for(int i=0; i<atmos_nSamples; i++) 		%EOL%    { %EOL%        float fHeight = length(v3SamplePoint); 			%EOL%        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); %EOL%        float fLightAngle = dot(atmos_v3LightDir, v3SamplePoint) / fHeight; 		%EOL%        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight; 			%EOL%        float fscatter = (fStartOffset + fDepth*(atmos_scale(fLightAngle) - atmos_scale(fCameraAngle))); 	%EOL%        v3Attenuate = exp(-fscatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	%EOL%        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 					%EOL%        v3SamplePoint += v3SampleRay; 		%EOL%    } 		%EOL%%EOL%    // Finally, scale the Mie and Rayleigh colors and set up the varying 			%EOL%    // variables for the pixel shader 	%EOL%    atmos_mieColor      = v3FrontColor * atmos_fKmESun; 				%EOL%    atmos_rayleighColor = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun); 						%EOL%    atmos_v3Direction = vVec  - v3Pos; 			%EOL%} 		%EOL%%EOL%void atmos_SkyFromAtmosphere(void) 		%EOL%{ %EOL%    // Get the ray from the camera to the vertex, and its length (which is the far %EOL%    // point of the ray passing through the atmosphere) %EOL%    vec3 v3Pos = gl_Vertex.xyz; 	%EOL%    vec3 v3Ray = v3Pos - vVec; 			%EOL%    float fFar = length(v3Ray); 					%EOL%    v3Ray /= fFar; 				%EOL%%EOL%    // Calculate the ray's starting position, then calculate its atmos_ing offset %EOL%    vec3 v3Start = vVec; %EOL%    float fHeight = length(v3Start); 		%EOL%    float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - atmos_fCameraHeight)); %EOL%    float fStartAngle = dot(v3Ray, v3Start) / fHeight; 	%EOL%    float fStartOffset = fDepth*atmos_scale(fStartAngle); %EOL%%EOL%    // Initialize the atmos_ing loop variables 		%EOL%    float fSampleLength = fFar / atmos_fSamples; 			%EOL%    float fScaledLength = fSampleLength * atmos_fScale; 				%EOL%    vec3 v3SampleRay = v3Ray * fSampleLength; 		%EOL%    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5; %EOL%%EOL%    // Now loop through the sample rays 		%EOL%    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); 		%EOL%    vec3 v3Attenuate;   %EOL%    for(int i=0; i<atmos_nSamples; i++) 			%EOL%    { 	%EOL%        float fHeight = length(v3SamplePoint); 	%EOL%        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); %EOL%        float fLightAngle = dot(atmos_v3LightDir, v3SamplePoint) / fHeight; %EOL%        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight; 	%EOL%        float fscatter = (fStartOffset + fDepth*(atmos_scale(fLightAngle) - atmos_scale(fCameraAngle))); 	%EOL%        v3Attenuate = exp(-fscatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	%EOL%        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 		%EOL%        v3SamplePoint += v3SampleRay; 		%EOL%    } %EOL%%EOL%    // Finally, scale the Mie and Rayleigh colors and set up the varying %EOL%    // variables for the pixel shader 					%EOL%    atmos_mieColor      = v3FrontColor * atmos_fKmESun; 			%EOL%    atmos_rayleighColor = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun); 				%EOL%    atmos_v3Direction = vVec - v3Pos; 				%EOL%} %EOL%%EOL%void atmos_vertex_main(inout vec4 VertexVIEW) %EOL%{ %EOL%    // Get camera position and height %EOL%    vVec = osg_ViewMatrixInverse[3].xyz; %EOL%    atmos_fCameraHeight = length(vVec); %EOL%    atmos_fCameraHeight2 = atmos_fCameraHeight*atmos_fCameraHeight; %EOL%    if(atmos_fCameraHeight >= atmos_fOuterRadius)%EOL%    { %EOL%        atmos_SkyFromSpace(); %EOL%    } %EOL%    else%EOL%    { %EOL%        atmos_SkyFromAtmosphere(); %EOL%    } %EOL%}%EOL%%EOL%";

    Atmosphere_Frag = "SimpleSky.Atmosphere.frag.glsl";
    _sources[Atmosphere_Frag] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint atmos_fragment_main%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.8%EOL%%EOL%uniform vec3 atmos_v3LightDir; %EOL%%EOL%uniform float atmos_g; 				%EOL%uniform float atmos_g2; %EOL%uniform float atmos_fWeather; %EOL%%EOL%varying vec3 atmos_v3Direction; 	%EOL%varying vec3 atmos_mieColor; %EOL%varying vec3 atmos_rayleighColor; %EOL%%EOL%const float fExposure = 4.0; %EOL%%EOL%float atmos_fastpow(in float x, in float y) %EOL%{ %EOL%    return x/(x+y-y*x); %EOL%} %EOL%%EOL%void atmos_fragment_main(inout vec4 color) %EOL%{ 				%EOL%    float fCos = dot(atmos_v3LightDir, atmos_v3Direction) / length(atmos_v3Direction); %EOL%    float fRayleighPhase = 1.0;  // 0.75 * (1.0 + fCos*fCos); %EOL%    float fMiePhase = 1.5 * ((1.0 - atmos_g2) / (2.0 + atmos_g2)) * (1.0 + fCos*fCos) / atmos_fastpow(1.0 + atmos_g2 - 2.0*atmos_g*fCos, 1.5); %EOL%    vec3 f4Color = fRayleighPhase * atmos_rayleighColor + fMiePhase * atmos_mieColor; %EOL%    vec3 skyColor = 1.0 - exp(f4Color * -fExposure); %EOL%    color.rgb = skyColor.rgb*atmos_fWeather; %EOL%    color.a = (skyColor.r+skyColor.g+skyColor.b) * 2.0; %EOL%}%EOL%%EOL%";

    Ground_ONeil_Vert = "SimpleSky.Ground.ONeil.vert.glsl";
    _sources[Ground_ONeil_Vert] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint atmos_vertex_main%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%%EOL%uniform bool oe_mode_GL_LIGHTING; %EOL%%EOL%uniform mat4 osg_ViewMatrixInverse;   // world camera position in [3].xyz %EOL%uniform mat4 osg_ViewMatrix;          // GL view matrix %EOL%uniform vec3 atmos_v3LightDir;        // The direction vector to the light source %EOL%uniform vec3 atmos_v3InvWavelength;   // 1 / pow(wavelength,4) for the rgb channels %EOL%uniform float atmos_fOuterRadius;     // Outer atmosphere radius %EOL%uniform float atmos_fOuterRadius2;    // fOuterRadius^2 		%EOL%uniform float atmos_fInnerRadius;     // Inner planetary radius %EOL%uniform float atmos_fInnerRadius2;    // fInnerRadius^2 %EOL%uniform float atmos_fKrESun;          // Kr * ESun 	%EOL%uniform float atmos_fKmESun;          // Km * ESun 		%EOL%uniform float atmos_fKr4PI;           // Kr * 4 * PI 	%EOL%uniform float atmos_fKm4PI;           // Km * 4 * PI 		%EOL%uniform float atmos_fScale;           // 1 / (fOuterRadius - fInnerRadius) 	%EOL%uniform float atmos_fScaleDepth;      // The scale depth %EOL%uniform float atmos_fScaleOverScaleDepth;     // fScale / fScaleDepth 	%EOL%uniform int atmos_nSamples; 	%EOL%uniform float atmos_fSamples; %EOL%%EOL%varying vec3 atmos_color;          // primary sky light color%EOL%varying vec3 atmos_atten;          // sky light attenuation factor%EOL%varying vec3 atmos_lightDir;       // light direction in view space%EOL%        %EOL%float atmos_fCameraHeight;            // The camera's current height 		%EOL%float atmos_fCameraHeight2;           // fCameraHeight^2 %EOL%%EOL%varying vec3 atmos_up;             // earth up vector at vertex location (not the normal)%EOL%varying float atmos_space;         // [0..1]: camera: 0=inner radius (ground); 1.0=outer radius%EOL%varying vec3 atmos_vert; %EOL%%EOL%vec3 vp_Normal;             // surface normal (from osgEarth)%EOL%%EOL%float atmos_scale(float fCos) 	%EOL%{ %EOL%    float x = 1.0 - fCos; %EOL%    return atmos_fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25)))); %EOL%} %EOL%%EOL%void atmos_GroundFromSpace(in vec4 vertexVIEW) %EOL%{ %EOL%    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere) %EOL%    vec3 v3Pos = vertexVIEW.xyz; %EOL%    vec3 v3Ray = v3Pos; %EOL%    float fFar = length(v3Ray); %EOL%    v3Ray /= fFar; %EOL%                %EOL%    vec4 ec4 = osg_ViewMatrix * vec4(0,0,0,1); %EOL%    vec3 earthCenter = ec4.xyz/ec4.w; %EOL%    vec3 normal = normalize(v3Pos-earthCenter); %EOL%    atmos_up = normal; %EOL%%EOL%    // Calculate the closest intersection of the ray with the outer atmosphere %EOL%    // (which is the near point of the ray passing through the atmosphere) %EOL%    float B = 2.0 * dot(-earthCenter, v3Ray); %EOL%    float C = atmos_fCameraHeight2 - atmos_fOuterRadius2; %EOL%    float fDet = max(0.0, B*B - 4.0*C); 	%EOL%    float fNear = 0.5 * (-B - sqrt(fDet)); 		%EOL%%EOL%    // Calculate the ray's starting position, then calculate its scattering offset %EOL%    vec3 v3Start = v3Ray * fNear; 			%EOL%    fFar -= fNear; %EOL%    float fDepth = exp((atmos_fInnerRadius - atmos_fOuterRadius) / atmos_fScaleDepth);%EOL%    float fCameraAngle = dot(-v3Ray, normal);  // try max(0, ...) to get rid of yellowing building tops%EOL%    float fLightAngle = dot(atmos_lightDir, normal); %EOL%    float fCameraScale = atmos_scale(fCameraAngle); %EOL%    float fLightScale = atmos_scale(fLightAngle); %EOL%    float fCameraOffset = fDepth*fCameraScale; %EOL%    float fTemp = fLightScale * fCameraScale; 		%EOL%%EOL%    // Initialize the scattering loop variables %EOL%    float fSampleLength = fFar / atmos_fSamples; 		%EOL%    float fScaledLength = fSampleLength * atmos_fScale; 					%EOL%    vec3 v3SampleRay = v3Ray * fSampleLength; 	%EOL%    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5; 	%EOL%%EOL%    // Now loop through the sample rays %EOL%    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); %EOL%    vec3 v3Attenuate = vec3(1,0,0); %EOL%%EOL%    for(int i=0; i<atmos_nSamples; ++i) %EOL%    {         %EOL%        float fHeight = length(v3SamplePoint-earthCenter); 			%EOL%        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); %EOL%        float fScatter = fDepth*fTemp - fCameraOffset; %EOL%        v3Attenuate = exp(-fScatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	%EOL%        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 					%EOL%        v3SamplePoint += v3SampleRay; 		%EOL%    } 	%EOL%%EOL%    atmos_color = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun + atmos_fKmESun); %EOL%    atmos_atten = v3Attenuate; %EOL%} 		%EOL%%EOL%void atmos_GroundFromAtmosphere(in vec4 vertexVIEW) 		%EOL%{ %EOL%    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere) %EOL%    vec3 v3Pos = vertexVIEW.xyz / vertexVIEW.w; %EOL%    vec3 v3Ray = v3Pos; %EOL%    float fFar = length(v3Ray); %EOL%    v3Ray /= fFar; %EOL%        %EOL%    vec4 ec4 = osg_ViewMatrix * vec4(0,0,0,1); %EOL%    vec3 earthCenter = ec4.xyz/ec4.w; %EOL%    vec3 normal = normalize(v3Pos-earthCenter); %EOL%    atmos_up = normal; %EOL%%EOL%    // Calculate the ray's starting position, then calculate its scattering offset %EOL%    float fDepth = exp((atmos_fInnerRadius - atmos_fCameraHeight) / atmos_fScaleDepth);%EOL%    float fCameraAngle = max(0.0, dot(-v3Ray, normal)); %EOL%    float fLightAngle = dot(atmos_lightDir, normal); %EOL%    float fCameraScale = atmos_scale(fCameraAngle); %EOL%    float fLightScale = atmos_scale(fLightAngle); %EOL%    float fCameraOffset = fDepth*fCameraScale; %EOL%    float fTemp = fLightScale * fCameraScale; %EOL%%EOL%    // Initialize the scattering loop variables 	%EOL%    float fSampleLength = fFar / atmos_fSamples; 		%EOL%    float fScaledLength = fSampleLength * atmos_fScale; 					%EOL%    vec3 v3SampleRay = v3Ray * fSampleLength; 	%EOL%    vec3 v3SamplePoint = v3SampleRay * 0.5; 	%EOL%%EOL%    // Now loop through the sample rays %EOL%    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); %EOL%    vec3 v3Attenuate;   %EOL%    for(int i=0; i<atmos_nSamples; i++) 		%EOL%    { %EOL%        float fHeight = length(v3SamplePoint-earthCenter); 			%EOL%        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); %EOL%        float fScatter = fDepth*fTemp - fCameraOffset; %EOL%        v3Attenuate = exp(-fScatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	%EOL%        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 					%EOL%        v3SamplePoint += v3SampleRay; 		%EOL%    } 		%EOL%%EOL%    atmos_color = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun + atmos_fKmESun); 			%EOL%    atmos_atten = v3Attenuate; %EOL%} %EOL%%EOL%void atmos_vertex_main(inout vec4 vertexVIEW) %EOL%{ %EOL%    if ( oe_mode_GL_LIGHTING == false ) return; %EOL%%EOL%    atmos_fCameraHeight = length(osg_ViewMatrixInverse[3].xyz); %EOL%    atmos_fCameraHeight2 = atmos_fCameraHeight*atmos_fCameraHeight; %EOL%    atmos_lightDir = normalize(gl_LightSource[0].position.xyz);  // view space%EOL%    atmos_vert = vertexVIEW.xyz; %EOL%%EOL%    atmos_space = max(0.0, (atmos_fCameraHeight-atmos_fInnerRadius)/(atmos_fOuterRadius-atmos_fInnerRadius));%EOL%%EOL%    if(atmos_fCameraHeight >= atmos_fOuterRadius) %EOL%    { %EOL%        atmos_GroundFromSpace(vertexVIEW); %EOL%    } %EOL%    else %EOL%    { %EOL%        atmos_GroundFromAtmosphere(vertexVIEW); %EOL%    } %EOL%}%EOL%%EOL%";

    Ground_ONeil_Frag = "SimpleSky.Ground.ONeil.frag.glsl";
    _sources[Ground_ONeil_Frag] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint atmos_fragment_main%EOL%#pragma vp_location   fragment_lighting%EOL%#pragma vp_order      0.8%EOL%%EOL%uniform bool oe_mode_GL_LIGHTING; %EOL%uniform float atmos_exposure;   // scene exposure (ground level)%EOL%varying vec3 atmos_lightDir;    // light direction (view coords)%EOL%varying vec3 atmos_color;       // atmospheric lighting color%EOL%varying vec3 atmos_atten;       // atmospheric lighting attentuation factor%EOL%varying vec3 atmos_up;          // earth up vector at fragment (in view coords)%EOL%varying float atmos_space;      // camera altitude (0=ground, 1=atmos outer radius)%EOL%varying vec3 atmos_vert; %EOL%        %EOL%vec3 vp_Normal;          // surface normal (from osgEarth)%EOL%%EOL%void atmos_fragment_main(inout vec4 color) %EOL%{ %EOL%    if ( oe_mode_GL_LIGHTING == false )%EOL%    {%EOL%        return; %EOL%    }%EOL%%EOL%    vec3 ambient = gl_LightSource[0].ambient.rgb;%EOL%    float minAmbient = ambient.r;%EOL%%EOL%    vec3 N = normalize(vp_Normal); %EOL%    vec3 L = normalize(atmos_lightDir); //normalize(gl_LightSource[0].position.xyz); %EOL%    vec3 U = normalize(atmos_up); %EOL%%EOL%    const float maxAmbient = 0.5;%EOL%    float daytime = max(0.0, dot(U,L));%EOL%    float ambientLightLevel = clamp(daytime, minAmbient, maxAmbient);%EOL%%EOL%    float NdotL = max(dot(N,L), 0.0);%EOL%%EOL%    const float lowAlt  = 1.0;%EOL%    const float highAlt = 14.0;%EOL%    float altitudeInfluence = 1.0 - clamp( (atmos_space-lowAlt)/(highAlt-lowAlt), 0.0, 1.0);%EOL%    float useNormals = altitudeInfluence * (1.0-ambientLightLevel);%EOL%%EOL%    // try to brighten up surfaces the sun is shining on%EOL%    float overExposure = 1.0;%EOL%%EOL%    // calculate the base scene color. Skip ambience since we'll be%EOL%    // factoring that in later.%EOL%    vec4 sceneColor = mix(color*overExposure, color*NdotL, useNormals);%EOL%%EOL%    if (NdotL > 0.0 ) { %EOL%        vec3 V = normalize(atmos_vert); %EOL%        vec3 H = reflect(-L, N);%EOL%        float HdotN = max(dot(H,N), 0.0); %EOL%        float shine = clamp(gl_FrontMaterial.shininess, 1.0, 128.0); %EOL%        sceneColor += gl_FrontLightProduct[0].specular * pow(HdotN, shine); %EOL%    } %EOL%%EOL%    // clamp the attentuation to the minimum ambient lighting:%EOL%    vec3 attenuation = max(atmos_atten, ambient); %EOL%%EOL%    // ramp exposure from ground (full) to space (50%).%EOL%    float exposure = atmos_exposure*clamp(1.0-atmos_space, 0.5, 1.0); %EOL%%EOL%    vec3 atmosColor = 1.0 - exp(-exposure * (atmos_color + sceneColor.rgb * attenuation)); %EOL%    color.rgb = gl_FrontMaterial.emission.rgb + atmosColor; %EOL%}%EOL%%EOL%";

    Moon_Vert = "SimpleSky.Moon.vert.glsl";
    _sources[Moon_Vert] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%uniform mat4 osg_ModelViewProjectionMatrix;%EOL%varying vec4 moon_TexCoord;%EOL%%EOL%void main() %EOL%{ %EOL%    moon_TexCoord = gl_MultiTexCoord0; %EOL%    gl_Position = osg_ModelViewProjectionMatrix * gl_Vertex; %EOL%}%EOL%%EOL%";

    Moon_Frag = "SimpleSky.Moon.frag.glsl";
    _sources[Moon_Frag] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%varying vec4 moon_TexCoord;%EOL%uniform sampler2D moonTex;%EOL%%EOL%void main( void ) %EOL%{ %EOL%   gl_FragColor = texture2D(moonTex, moon_TexCoord.st);%EOL%}%EOL%%EOL%";

    Stars_Vert = "SimpleSky.Stars.vert.glsl";
    _sources[Stars_Vert] = "#version $GLSL_VERSION_STR%EOL%%EOL%uniform vec3 atmos_v3LightDir; %EOL%uniform mat4 osg_ViewMatrixInverse; %EOL%out float visibility; %EOL%out vec4 osg_FrontColor; %EOL%%EOL%float remap( float val, float vmin, float vmax, float r0, float r1 ) %EOL%{ %EOL%    float vr = (clamp(val, vmin, vmax)-vmin)/(vmax-vmin); %EOL%    return r0 + vr * (r1-r0); %EOL%} %EOL%%EOL%void main() %EOL%{ %EOL%    osg_FrontColor = gl_Color; %EOL%    gl_PointSize = gl_Color.r * 14.0; %EOL%    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; %EOL%    vec3 eye = osg_ViewMatrixInverse[3].xyz; %EOL%    float hae = length(eye) - 6378137.0; %EOL%    // highness: visibility increases with altitude%EOL%    float highness = remap( hae, 25000.0, 150000.0, 0.0, 1.0 ); %EOL%    eye = normalize(eye); %EOL%    // darkness: visibility increase as the sun goes around the other side of the earth%EOL%    float darkness = 1.0-remap(dot(eye,atmos_v3LightDir), -0.25, 0.0, 0.0, 1.0); %EOL%    visibility = clamp(highness + darkness, 0.0, 1.0); %EOL%}%EOL%%EOL%";

    Stars_Frag = "SimpleSky.Stars.frag.glsl";
    _sources[Stars_Frag] = "#version $GLSL_VERSION_STR%EOL%%EOL%in float visibility; %EOL%in vec4 osg_FrontColor; %EOL%%EOL%void main( void ) %EOL%{ %EOL%    float b1 = 1.0-(2.0*abs(gl_PointCoord.s-0.5)); %EOL%    float b2 = 1.0-(2.0*abs(gl_PointCoord.t-0.5)); %EOL%    float i = b1*b1 * b2*b2; %EOL%    gl_FragColor = osg_FrontColor * i * visibility; %EOL%}%EOL%%EOL%";
    
    Stars_GLES_Vert = "SimpleSky.Stars.GLES.vert.glsl";
    _sources[Stars_GLES_Vert] = "#version $GLSL_VERSION_STR %EOL%$GLSL_DEFAULT_PRECISION_FLOAT %EOL%%EOL%uniform vec3 atmos_v3LightDir; %EOL%uniform mat4 osg_ViewMatrixInverse; %EOL%varying float visibility; %EOL%varying vec4 osg_FrontColor; %EOL%%EOL%float remap( float val, float vmin, float vmax, float r0, float r1 ) %EOL%{ %EOL%    float vr = (clamp(val, vmin, vmax)-vmin)/(vmax-vmin); %EOL%    return r0 + vr * (r1-r0); %EOL%} %EOL%%EOL%void main() %EOL%{ %EOL%    osg_FrontColor = gl_Color; %EOL%    gl_PointSize = gl_Color.r * 2.0; %EOL%    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; %EOL%    vec3 eye = osg_ViewMatrixInverse[3].xyz; %EOL%    float hae = length(eye) - 6378137.0; %EOL%    // highness: visibility increases with altitude%EOL%    float highness = remap( hae, 25000.0, 150000.0, 0.0, 1.0 ); %EOL%    eye = normalize(eye); %EOL%    // darkness: visibility increase as the sun goes around the other side of the earth%EOL%    float darkness = 1.0-remap(dot(eye,atmos_v3LightDir), -0.25, 0.0, 0.0, 1.0); %EOL%    visibility = clamp(highness + darkness, 0.0, 1.0); %EOL%}%EOL%%EOL%";

    Stars_GLES_Frag = "SimpleSky.Stars.GLES.frag.glsl";
    _sources[Stars_GLES_Frag] = "#version $GLSL_VERSION_STR %EOL%$GLSL_DEFAULT_PRECISION_FLOAT %EOL%%EOL%varying float visibility; %EOL%varying vec4 osg_FrontColor; %EOL%void main( void ) %EOL%{ %EOL%    gl_FragColor = osg_FrontColor * visibility; %EOL%}%EOL%%EOL%";

    Sun_Vert = "SimpleSky.Sun.vert.glsl";
    _sources[Sun_Vert] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%varying vec3 atmos_v3Direction; %EOL%%EOL%void main() %EOL%{ %EOL%    vec3 v3Pos = gl_Vertex.xyz; %EOL%    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; %EOL%    atmos_v3Direction = vec3(0.0,0.0,1.0) - v3Pos; %EOL%    atmos_v3Direction = atmos_v3Direction/length(atmos_v3Direction); %EOL%}%EOL%%EOL%";

    Sun_Frag = "SimpleSky.Sun.frag.glsl";
    _sources[Sun_Frag] = "#version $GLSL_VERSION_STR %EOL%$GLSL_DEFAULT_PRECISION_FLOAT %EOL%%EOL%uniform float atmos_sunAlpha; %EOL%varying vec3 atmos_v3Direction; %EOL%%EOL%float atmos_fastpow(in float x, in float y) %EOL%{ %EOL%    return x/(x+y-y*x); %EOL%} %EOL%%EOL%void main( void ) %EOL%{ %EOL%   float fCos = -atmos_v3Direction[2];          %EOL%   float fMiePhase = 0.050387596899224826 * (1.0 + fCos*fCos) / atmos_fastpow(1.9024999999999999 - -1.8999999999999999*fCos, 1.5); %EOL%   gl_FragColor.rgb = fMiePhase*vec3(.3,.3,.2); %EOL%   gl_FragColor.a = atmos_sunAlpha*gl_FragColor.r; %EOL%}%EOL%%EOL%";
}
