/** CMake Template File - compiled into AutoGenShaders.cpp */
#include <osgEarthDrivers/bumpmap/BumpMapShaders>

using namespace osgEarth::BumpMap;

Shaders::Shaders()
{
    VertexView = "BumpMap.vert.view.glsl";
    _sources[VertexView] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_bumpmap_vertexView%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%%EOL%uniform vec4 oe_tile_key;%EOL%uniform float oe_bumpmap_scale;%EOL%uniform float oe_bumpmap_baseLOD;%EOL%%EOL%out vec4 oe_layer_tilec;%EOL%out vec3 vp_Normal;%EOL%%EOL%out vec2 oe_bumpmap_coords;%EOL%out float oe_bumpmap_range;%EOL%flat out mat3 oe_bumpmap_normalMatrix;%EOL%%EOL%%EOL%vec2 oe_bumpmap_scaleCoords(in vec2 coords, in float targetLOD)%EOL%{%EOL%    float dL = oe_tile_key.z - targetLOD;%EOL%    float factor = exp2(dL);%EOL%    float invFactor = 1.0/factor;%EOL%    vec2 scale = vec2(invFactor);%EOL%    vec2 result = coords * scale;%EOL%%EOL%    // For upsampling we need to calculate an offset as well%EOL%    float upSampleToggle = factor >= 1.0 ? 1.0 : 0.0;%EOL%    {%EOL%        vec2 a = floor(oe_tile_key.xy * invFactor);%EOL%        vec2 b = a * factor;%EOL%        vec2 c = (a+1.0) * factor;%EOL%        vec2 offset = (oe_tile_key.xy-b)/(c-b);%EOL%        result += upSampleToggle * offset;%EOL%    }%EOL%%EOL%    return result;%EOL%}%EOL%%EOL%void oe_bumpmap_vertexView(inout vec4 vertexView)%EOL%{%EOL%    oe_bumpmap_range = -vertexView.z;%EOL%%EOL%    // quantize the scale factor%EOL%    float iscale = float(int(oe_bumpmap_scale));%EOL%%EOL%    // scale sampling coordinates to a target LOD.%EOL%    oe_bumpmap_coords = oe_bumpmap_scaleCoords(oe_layer_tilec.st, floor(oe_bumpmap_baseLOD)) * iscale;%EOL%%EOL%    // propagate normal matrix to fragment stage%EOL%    oe_bumpmap_normalMatrix = gl_NormalMatrix;%EOL%}%EOL%%EOL%";

    FragmentSimple = "BumpMap.frag.simple.glsl";
    _sources[FragmentSimple] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_bumpmap_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.3%EOL%%EOL%#pragma include BumpMap.frag.common.glsl%EOL%%EOL%in vec3 vp_Normal;%EOL%in vec2 oe_bumpmap_coords;%EOL%flat in mat3 oe_bumpmap_normalMatrix;%EOL%in vec3 oe_UpVectorView;%EOL%%EOL%uniform sampler2D oe_bumpmap_tex;%EOL%uniform float     oe_bumpmap_intensity;%EOL%uniform float     oe_bumpmap_slopeFactor;%EOL%%EOL%%EOL%void oe_bumpmap_fragment(inout vec4 color)%EOL%{%EOL%	// sample the bump map%EOL%    vec3 bump = oe_bumpmap_normalMatrix * normalize(texture2D(oe_bumpmap_tex, oe_bumpmap_coords).xyz*2.0-1.0);%EOL%    %EOL%    // calculate slope from normal:%EOL%    float slope = clamp( (1.0-dot(oe_UpVectorView, vp_Normal))*oe_bumpmap_slopeFactor, 0.0, 1.0);%EOL%    %EOL%	// permute the normal with the bump.%EOL%	vp_Normal = normalize(vp_Normal + bump*oe_bumpmap_intensity*slope);%EOL%}%EOL%%EOL%";

    FragmentProgressive = "BumpMap.frag.progressive.glsl";
    _sources[FragmentProgressive] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_bumpmap_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.3%EOL%%EOL%#pragma include BumpMap.frag.common.glsl%EOL%%EOL%uniform sampler2D oe_bumpmap_tex;%EOL%uniform float     oe_bumpmap_intensity;%EOL%uniform int       oe_bumpmap_octaves;%EOL%uniform float     oe_bumpmap_maxRange;%EOL%uniform float     oe_bumpmap_slopeFactor;%EOL%%EOL%// framework/stage global%EOL%in vec3 vp_Normal;%EOL%in vec3 oe_UpVectorView;%EOL%%EOL%// from BumpMap.model.vert.glsl%EOL%in vec2 oe_bumpmap_coords;%EOL%flat in mat3 oe_bumpmap_normalMatrix;%EOL%%EOL%// from BumpMap.view.vert.glsl%EOL%in float oe_bumpmap_range;%EOL%%EOL%// Entry point for progressive blended bump maps%EOL%void oe_bumpmap_fragment(inout vec4 color)%EOL%{%EOL%	// sample the bump map%EOL%    const float amplitudeDecay = 1.0; // no decay.%EOL%    float maxLOD = float(oe_bumpmap_octaves)+1.0;%EOL%%EOL%    // starter vector:%EOL%    vec3 bump = vec3(0.0);    %EOL%    float scale = 1.0;%EOL%    float amplitude = 1.0;%EOL%    float limit = oe_bumpmap_range;%EOL%    float range = oe_bumpmap_maxRange;%EOL%    float lastRange = oe_bumpmap_maxRange;%EOL%    for(float lod = 1.0; lod < maxLOD; lod += 1.0, scale *= 2.0, amplitude *= amplitudeDecay)%EOL%    {%EOL%        float fadeIn = 1.0;%EOL%        if ( range <= limit && limit < oe_bumpmap_maxRange )%EOL%            fadeIn = clamp((lastRange-limit)/(lastRange-range), 0.0, 1.0);%EOL%        bump += (texture2D(oe_bumpmap_tex, oe_bumpmap_coords*scale).xyz*2.0-1.0)*amplitude*fadeIn;%EOL%        if ( range <= limit )%EOL%            break;%EOL%        lastRange = range;%EOL%        range = oe_bumpmap_maxRange/exp(lod);%EOL%    }%EOL%%EOL%    // finally, transform into view space and normalize the vector.%EOL%    bump = normalize(oe_bumpmap_normalMatrix*bump);%EOL%    %EOL%    // calculate slope from normal:%EOL%    float slope = mix(1.0, 1.0 - dot(oe_UpVectorView, vp_Normal), oe_bumpmap_slopeFactor);%EOL%%EOL%	// permute the normal with the bump.%EOL%	vp_Normal = normalize(vp_Normal + bump*oe_bumpmap_intensity*slope);%EOL%}%EOL%%EOL%";

    FragmentCommon = "BumpMap.frag.common.glsl";
    _sources[FragmentCommon] = "#pragma vp_define OE_USE_NORMAL_MAP%EOL%%EOL%#ifdef OE_USE_NORMAL_MAP%EOL%%EOL%// normal map version:%EOL%uniform sampler2D oe_tile_normalTex;%EOL%in vec2 oe_normalMapCoords;%EOL%%EOL%float oe_bumpmap_getSlope()%EOL%{%EOL%    vec4 encodedNormal = texture2D(oe_nmap_normalTex, oe_normalMapCoords);%EOL%    vec3 normalTangent = normalize(encodedNormal.xyz*2.0-1.0);%EOL%    return clamp((1.0-normalTangent.z)/0.8, 0.0, 1.0);%EOL%}%EOL%%EOL%#else // OE_USE_NORMAL_MAP%EOL%%EOL%// non- normal map version:%EOL%in float oe_bumpmap_slope;%EOL%%EOL%float oe_bumpmap_getSlope()%EOL%{%EOL%    return oe_bumpmap_slope;%EOL%}%EOL%%EOL%#endif // OE_USE_NORMAL_MAP%EOL%%EOL%";
};
