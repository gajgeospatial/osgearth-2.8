// ***DO NOT EDIT THIS FILE - IT IS AUTOMATICALLY GENERATED BY CMAKE***

#include <osgEarthDrivers/ocean_simple/SimpleOceanShaders>

using namespace osgEarth::SimpleOcean;

Shaders::Shaders()
{    
    VERT_MODEL = "SimpleOcean.VS.glsl";
    _sources[VERT_MODEL] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_name       SimpleOcean with Proxy VS%EOL%#pragma vp_entryPoint oe_ocean_vertex%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_define     USE_OCEAN_MASK%EOL%%EOL%// convert an ecef coordinate to lon/lat (low precision)%EOL%vec2 ocean_xyz_to_spherical(in vec3 xyz)  %EOL%{  %EOL%    float r = length(xyz);  %EOL%    float lat = acos(xyz.z/r);  %EOL%    float lon = atan(xyz.y, xyz.x);  %EOL%    return vec2(lon,lat);  %EOL%}  %EOL%%EOL%// uniforms%EOL%uniform mat4 osg_ViewMatrixInverse;  %EOL%uniform float osg_FrameTime;  %EOL%uniform sampler2D ocean_data;                 // heightfield encoded into 16 bit texture%EOL%uniform float ocean_seaLevel;                 // sea level offset%EOL%uniform sampler2D ocean_surface_tex;          // surface texture%EOL%uniform bool ocean_has_surface_tex;           // whether there's a surface texture%EOL%%EOL%// outputs to fragment stage%EOL%out vec4 ocean_surface_tex_coord;  %EOL%out float ocean_v_msl;                      // elevation (MSL) of camera%EOL%out float ocean_v_range;                    // distance from camera to current vertex%EOL%out float ocean_v_enorm;                    // normalized terrain height at vertex [0..1]%EOL%%EOL%// stage global%EOL%vec3 vp_Normal;%EOL%%EOL%%EOL%#ifdef USE_OCEAN_MASK%EOL%out vec4 ocean_mask_tex_coord;%EOL%%EOL%// Ocean mask version:%EOL%void oe_ocean_vertex(inout vec4 VertexMODEL)  %EOL%{  %EOL%    // adjust our vert for the sea level - extrude along the normal vector %EOL%    // (this must be done in modelview space to preserve precision)%EOL%    vec4 mvVertex = VertexMODEL;  %EOL%    vec3 mvNormal = gl_NormalMatrix * gl_Normal;  %EOL%    vec4 mvVertex2 = vec4(mvVertex.xyz + (mvNormal * ocean_seaLevel), mvVertex.w );  %EOL%%EOL%    VertexMODEL = mvVertex2;  %EOL%%EOL%    // ocean mask texture coordinate:%EOL%    ocean_mask_tex_coord = gl_MultiTexCoord0;  %EOL%%EOL%    // send interpolated params to the fs:%EOL%    vec4 eye = osg_ViewMatrixInverse * vec4(0,0,0,1);  %EOL%%EOL%    // height of camera above sea level:%EOL%    ocean_v_msl = length(eye.xyz/eye.w) - 6378137.0 + ocean_seaLevel;  %EOL%%EOL%    // disatnce to camera:%EOL%    ocean_v_range = ocean_v_msl;  %EOL%%EOL%    // scale the texture mapping to something reasonable:%EOL%    vec4 worldVertex = osg_ViewMatrixInverse * mvVertex;  %EOL%    vec2 lonlat = ocean_xyz_to_spherical( worldVertex.xyz/worldVertex.w );  %EOL%    ocean_surface_tex_coord.xy = lonlat/0.0005;%EOL%    ocean_surface_tex_coord.zw = ocean_surface_tex_coord.xy;  %EOL%    ocean_surface_tex_coord.w -= mod(0.1*osg_FrameTime,25.0)/25.0; %EOL%}%EOL%%EOL%#else%EOL%%EOL%// Proxy layer version:%EOL%void oe_ocean_vertex(inout vec4 VertexVIEW)  %EOL%{  %EOL%    // adjust our vert for the sea level - extrude along the normal vector %EOL%    // (this must be done in view space to preserve precision)%EOL%    vec4 mvVertex = VertexVIEW;  %EOL%    vec3 mvNormal = vp_Normal;  %EOL%    vec4 mvVertex2 = vec4(mvVertex.xyz + (mvNormal * ocean_seaLevel), mvVertex.w );  %EOL%%EOL%    VertexVIEW = mvVertex2;  %EOL%%EOL%    // read normalized [0..1] elevation data from the height texture:%EOL%    ocean_v_enorm = texture2D( ocean_data, gl_MultiTexCoord0.st ).r;  %EOL%%EOL%    // send interpolated params to the fs:%EOL%    vec4 eye = osg_ViewMatrixInverse * vec4(0,0,0,1);  %EOL%%EOL%    // height of camera above sea level:%EOL%    ocean_v_msl = length(eye.xyz/eye.w) - 6378137.0 + ocean_seaLevel;  %EOL%%EOL%    // disatnce to camera:%EOL%    ocean_v_range = ocean_v_msl;  %EOL%%EOL%    // scale the texture mapping to something reasonable:%EOL%    vec4 worldVertex = osg_ViewMatrixInverse * mvVertex;  %EOL%    vec2 lonlat = ocean_xyz_to_spherical( worldVertex.xyz/worldVertex.w );  %EOL%    ocean_surface_tex_coord.xy = lonlat/0.0005;%EOL%    ocean_surface_tex_coord.zw = ocean_surface_tex_coord.xy;  %EOL%    ocean_surface_tex_coord.w -= mod(0.1*osg_FrameTime,25.0)/25.0; %EOL% }%EOL%%EOL%#endif%EOL%%EOL%";

    FRAG = "SimpleOcean.FS.glsl";
    _sources[FRAG] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_name       SimpleOcean Proxy FS%EOL%#pragma vp_entryPoint oe_ocean_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.6%EOL%#pragma vp_define     USE_OCEAN_MASK%EOL%%EOL%// clamps a value to the vmin/vmax range, then re-maps it to the r0/r1 range:%EOL%float ocean_remap( float val, float vmin, float vmax, float r0, float r1 )  %EOL%{  %EOL%    float vr = (clamp(val, vmin, vmax)-vmin)/(vmax-vmin);  %EOL%    return r0 + vr * (r1-r0);  %EOL%}  %EOL%%EOL%// uniforms%EOL%uniform bool ocean_has_surface_tex;           // whether there's a surface texture%EOL%uniform sampler2D ocean_surface_tex;          // surface texture%EOL%uniform float ocean_seaLevel;                 // sea level offset%EOL%uniform float ocean_lowFeather;               // offset from sea level at which to start feathering out%EOL%uniform float ocean_highFeather;              // offset from sea level at which to stop feathering out%EOL%uniform vec4  ocean_baseColor;                // base ocean color before processing%EOL%uniform float ocean_max_range;                // maximum visible distance of the ocean%EOL%uniform float ocean_fade_range;               // distance over which to fade in the ocean%EOL%uniform float oe_ocean_alpha;                 // The ocean alpha%EOL%%EOL%// inputs from vertex stage%EOL%in float ocean_v_msl;                    // elevation (MSL) of camera%EOL%in float ocean_v_range;                  // distance from camera to current vertex%EOL%in float ocean_v_enorm;                  // normalized terrain height at vertex [0..1]%EOL%in vec4 ocean_surface_tex_coord;         // surface texture coords%EOL%%EOL%%EOL%#ifdef USE_OCEAN_MASK%EOL%%EOL%uniform sampler2D ocean_data;%EOL%in vec4 ocean_mask_tex_coord;%EOL%%EOL%// Ocean mask version:%EOL%void oe_ocean_fragment(inout vec4 color)  %EOL%{  %EOL%    color = ocean_baseColor;  %EOL%%EOL%    // amplify the range's effect on alpha when the camera elevation gets low%EOL%    float rangeFactor = ocean_remap( ocean_v_msl, -10000.0, 10000.0, 10.0, 1.0 );  %EOL%%EOL%    // affect alpha based on the distance from the camera%EOL%    float rangeEffect = ocean_remap( %EOL%       ocean_v_range, %EOL%       ocean_max_range - ocean_fade_range, ocean_max_range * rangeFactor, %EOL%       1.0, 0.0);  %EOL%%EOL%    // start with the surface texture.%EOL%    if (ocean_has_surface_tex)  %EOL%    {  %EOL%        float a1 = texture(ocean_surface_tex, ocean_surface_tex_coord.xy).r;  %EOL%        float a2 = -texture(ocean_surface_tex, ocean_surface_tex_coord.zw).r;  %EOL%        const float contrast = 1.0;%EOL%        float brightness = 1.0 + 0.5*(a1+a2);%EOL%        color = clamp(((color-0.5)*contrast + 0.5) * brightness, 0.0, 1.0);%EOL%        color.a = ocean_baseColor.a; %EOL%        color.a = max(color.a, ocean_baseColor.a);%EOL%    }  %EOL%%EOL%    // effect of the terrain mask [0..1] in the alpha component.%EOL%    float maskEffect = texture(ocean_data, ocean_mask_tex_coord.xy).a;  %EOL%%EOL%    // color it%EOL%    color = vec4( color.rgb, maskEffect * rangeEffect * color.a * oe_ocean_alpha );  %EOL%%EOL%    //%QUOTE%    color = vec4( 1, 0, 0, 1 );   // debugging%EOL%}%EOL%%EOL%#else%EOL%%EOL%// Proxy layer version:%EOL%void oe_ocean_fragment(inout vec4 color)  %EOL%{  %EOL%    color = ocean_baseColor;  %EOL%%EOL%    // amplify the range's effect on alpha when the camera elevation gets low%EOL%    float rangeFactor = ocean_remap( ocean_v_msl, -10000.0, 10000.0, 10.0, 1.0 );  %EOL%%EOL%    // affect alpha based on the distance from the camera%EOL%    float rangeEffect = ocean_remap( %EOL%        ocean_v_range, %EOL%        ocean_max_range - ocean_fade_range, ocean_max_range * rangeFactor, %EOL%        1.0, 0.0);  %EOL%%EOL%    // start with the surface texture.%EOL%    if (ocean_has_surface_tex)  %EOL%    {  %EOL%        float a1 = texture(ocean_surface_tex, ocean_surface_tex_coord.xy).r;  %EOL%        float a2 = -texture(ocean_surface_tex, ocean_surface_tex_coord.zw).r;  %EOL%        const float contrast = 1.0;%EOL%        float brightness = 1.0 + 0.5*(a1+a2);%EOL%        color = clamp(((color-0.5)*contrast + 0.5) * brightness, 0.0, 1.0);%EOL%        color.a = ocean_baseColor.a; %EOL%        color.a = max(color.a, ocean_baseColor.a);%EOL%    }  %EOL%%EOL%    // un-normalize the heightfield data%EOL%    float terrainHeight = (ocean_v_enorm * 65535.0) - 32768.0;  %EOL%%EOL%    // heightfield's effect on alpha [0..1]%EOL%    float terrainEffect = ocean_remap( terrainHeight, ocean_seaLevel+ocean_lowFeather, ocean_seaLevel+ocean_highFeather, 1.0, 0.0 );   %EOL%%EOL%    // color it%EOL%    color = vec4( color.rgb, terrainEffect * rangeEffect * oe_ocean_alpha * color.a );  %EOL%%EOL%    //     color = vec4( 1, 0, 0, 1 );   // debugging%EOL%}%EOL%%EOL%#endif%EOL%%EOL%";
}
