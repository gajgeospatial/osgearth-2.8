// ***DO NOT EDIT THIS FILE - IT IS AUTOMATICALLY GENERATED BY CMAKE***

#include <osgEarthDrivers/engine_rex/Shaders>

using namespace osgEarth::Drivers::RexTerrainEngine;

Shaders::Shaders()
{
    ENGINE_VERT_MODEL = "RexEngine.vert.glsl";
    _sources[ENGINE_VERT_MODEL] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_name       REX Engine - Vertex%EOL%#pragma vp_entryPoint oe_rexEngine_vert%EOL%#pragma vp_location   vertex_model%EOL%#pragma vp_order      0.0%EOL%%EOL%// uniforms%EOL%uniform vec4 oe_terrain_color;%EOL%%EOL%// outputs%EOL%out vec4 vp_Color;%EOL%out vec3 vp_Normal;%EOL%%EOL%out vec4 oe_layer_texc;%EOL%out vec4 oe_layer_tilec;%EOL%out vec3 oe_UpVectorView;%EOL%%EOL%out float oe_rex_morphFactor;%EOL%%EOL%void oe_rexEngine_vert(inout vec4 vertexModel)%EOL%{%EOL%    // Texture coordinate for the tile (always 0..1)%EOL%    oe_layer_tilec = gl_MultiTexCoord0;%EOL%%EOL%    // Color of the underlying map geometry (untextured)%EOL%    vp_Color = oe_terrain_color;%EOL%	%EOL%    // %QUOTE%up%QUOTE% vector at this vertex in view space, which we will later%EOL%    // need in order to elevate the terrain%EOL%	oe_UpVectorView = normalize(gl_NormalMatrix*vp_Normal);%EOL%%EOL%    // initialize:%EOL%    oe_rex_morphFactor = 0.0;%EOL%}%EOL%%EOL%";

    MORPHING_VERT = "RexEngine.Morphing.vert.glsl";
    _sources[MORPHING_VERT] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_name       REX Engine - Morphing%EOL%#pragma vp_entryPoint oe_rexEngine_morph%EOL%#pragma vp_location   vertex_model%EOL%#pragma vp_order      0.5%EOL%#pragma vp_define     OE_REX_VERTEX_MORPHING%EOL%%EOL%// stage%EOL%vec3 vp_Normal; // up vector%EOL%%EOL%vec4 oe_layer_texc;%EOL%vec4 oe_layer_tilec;%EOL%%EOL%out float oe_rex_morphFactor;%EOL%%EOL%uniform sampler2D oe_tile_elevationTex;%EOL%uniform mat4      oe_tile_elevationTexMatrix;%EOL%uniform vec2	  oe_tile_morph;%EOL%uniform float     oe_tile_size;%EOL%uniform vec4	  oe_tile_key;%EOL%%EOL%// SDK functions:%EOL%float oe_terrain_getElevation(in vec2 uv);%EOL%%EOL%// Vertex Markers:%EOL%#define MASK_MARKER_DISCARD  0.0%EOL%#define MASK_MARKER_NORMAL   1.0%EOL%#define MASK_MARKER_SKIRT    2.0%EOL%#define MASK_MARKER_BOUNDARY 3.0%EOL%%EOL%%EOL%// Morphs a vertex using a neighbor.%EOL%void oe_rex_MorphVertex(inout vec3 position, inout vec2 uv, in vec3 neighborPosition)%EOL%{%EOL%   float halfSize        = (0.5*oe_tile_size)-0.5;%EOL%   float twoOverHalfSize = 2.0/(oe_tile_size-1.0);%EOL%   %EOL%   vec2 fractionalPart = fract(uv * halfSize) * twoOverHalfSize;%EOL%   uv = clamp(uv - (fractionalPart * oe_rex_morphFactor), 0.0, 1.0);%EOL%   //uv = clamp(uv, 0, 1);%EOL%%EOL%   vec3 morphVector = neighborPosition.xyz - position.xyz;%EOL%   position.xyz = position.xyz + morphVector*oe_rex_morphFactor;%EOL%}%EOL%%EOL%%EOL%// Compute a morphing factor based on model-space inputs:%EOL%float oe_rex_ComputeMorphFactor(in vec4 position, in vec3 up)%EOL%{%EOL%    // Find the %QUOTE%would be%QUOTE% position of the vertex (the position the vertex would%EOL%    // assume with no morphing)%EOL%	vec4 wouldBePosition = position;%EOL%%EOL%	#ifdef OE_REX_VERTEX_MORPHING%EOL%        float elev = oe_terrain_getElevation( oe_layer_tilec.st );%EOL%		wouldBePosition.xyz += up*elev;%EOL%	#endif%EOL%%EOL%    vec4 wouldBePositionView = gl_ModelViewMatrix * wouldBePosition;%EOL%    %EOL%    float fDistanceToEye = length(wouldBePositionView.xyz); // or just -z.%EOL%	float fMorphLerpK  = 1.0f - clamp( oe_tile_morph[0] - fDistanceToEye * oe_tile_morph[1], 0.0, 1.0 );%EOL%    return fMorphLerpK;%EOL%}%EOL%%EOL%%EOL%void oe_rexEngine_morph(inout vec4 vertexModel)%EOL%{    %EOL%    // compute the morphing factor to send down the pipe.%EOL%    // we need this even if vertex-morphing is off since we use it for %EOL%    // other things (like image blending)%EOL%    if (oe_layer_tilec.z == MASK_MARKER_NORMAL)%EOL%    {%EOL%        oe_rex_morphFactor = oe_rex_ComputeMorphFactor(vertexModel, vp_Normal);    %EOL%%EOL%#ifdef OE_REX_VERTEX_MORPHING%EOL%        vec3 neighborVertexModel = gl_MultiTexCoord1.xyz;%EOL%        oe_rex_MorphVertex(vertexModel.xyz, oe_layer_tilec.st, neighborVertexModel.xyz);%EOL%#endif%EOL%    }%EOL%    else%EOL%    {%EOL%        oe_rex_morphFactor = 0.0;%EOL%    }%EOL%}%EOL%%EOL%%EOL%";

    ENGINE_VERT_VIEW = "RexEngine.vert.view.glsl";
    _sources[ENGINE_VERT_VIEW] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_name       REX Engine - Vertex/View%EOL%#pragma vp_entryPoint oe_rex_elevateVertexAndSetTexCoords%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.4%EOL%%EOL%// Stage globals%EOL%vec4 oe_layer_tilec;%EOL%vec4 oe_layer_texc;%EOL%vec4 oe_layer_texcParent;%EOL%vec3 oe_UpVectorView;%EOL%%EOL%vec4 vp_Color;%EOL%%EOL%uniform mat4 oe_layer_texMatrix;%EOL%uniform mat4 oe_layer_texParentMatrix;%EOL%%EOL%uniform float oe_layer_minRange;%EOL%uniform float oe_layer_maxRange;%EOL%uniform float oe_layer_attenuationRange;%EOL%%EOL%// SDK functions:%EOL%float oe_terrain_getElevation(in vec2 uv);%EOL%%EOL%out float oe_layer_rangeOpacity;%EOL%%EOL%// Vertex Markers:%EOL%#define MASK_MARKER_DISCARD  0.0%EOL%#define MASK_MARKER_NORMAL   1.0%EOL%#define MASK_MARKER_SKIRT    2.0%EOL%#define MASK_MARKER_BOUNDARY 3.0%EOL%%EOL%void oe_rex_elevateVertexAndSetTexCoords(inout vec4 vertexView)%EOL%{%EOL%    float elev = %EOL%        oe_layer_tilec.z == MASK_MARKER_BOUNDARY || oe_layer_tilec.z == MASK_MARKER_DISCARD ? 0.0f%EOL%        : oe_terrain_getElevation( oe_layer_tilec.st );%EOL%%EOL%    vertexView.xyz += oe_UpVectorView * elev;%EOL%%EOL%#if 0%EOL%    // calculate the texture coordinates:%EOL%    oe_layer_texc       = oe_layer_texMatrix       * oe_layer_tilec;%EOL%	oe_layer_texcParent = oe_layer_texParentMatrix * oe_layer_tilec;%EOL%#else%EOL%    // faster (MAD)%EOL%	oe_layer_texc.xy	   = oe_layer_tilec.xy*oe_layer_texMatrix[0][0] + oe_layer_texMatrix[3].xy;%EOL%    oe_layer_texc.zw       = oe_layer_tilec.zw;%EOL%    oe_layer_texcParent.xy = oe_layer_tilec.xy*oe_layer_texParentMatrix[0][0] + oe_layer_texParentMatrix[3].xy;%EOL%    oe_layer_texcParent.zw = oe_layer_tilec.zw;%EOL%#endif%EOL%%EOL%   float range = max(-vertexView.z, 0.0);%EOL%%EOL%   float attenMin    = oe_layer_minRange - oe_layer_attenuationRange;%EOL%   float attenMax    = oe_layer_maxRange + oe_layer_attenuationRange;%EOL%%EOL%   oe_layer_rangeOpacity =%EOL%       oe_layer_minRange >= oe_layer_maxRange                   ? 1.0 :%EOL%       range >= oe_layer_minRange && range < oe_layer_maxRange  ? 1.0 :%EOL%       range < oe_layer_minRange                                ? clamp((range-attenMin)/oe_layer_attenuationRange, 0.0, 1.0) :%EOL%       range > oe_layer_maxRange                                ? clamp((attenMax-range)/oe_layer_attenuationRange, 0.0, 1.0) :%EOL%       0.0;%EOL%}%EOL%%EOL%";

    ENGINE_FRAG = "RexEngine.frag.glsl";
    _sources[ENGINE_FRAG] = "#version 330%EOL%%EOL%#pragma vp_name       REX Engine - Fragment%EOL%#pragma vp_entryPoint oe_rexEngine_frag%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.5%EOL%#pragma vp_define     OE_REX_GL_BLENDING%EOL%#pragma vp_define     OE_REX_MORPH_IMAGERY%EOL%%EOL%uniform bool      oe_isPickCamera;%EOL%uniform sampler2D oe_layer_tex;%EOL%uniform int       oe_layer_uid;%EOL%uniform int       oe_layer_order;%EOL%uniform float     oe_layer_opacity;%EOL%%EOL%#ifdef OE_REX_MORPH_IMAGERY%EOL%uniform sampler2D oe_layer_texParent;%EOL%uniform float oe_layer_texParentExists;%EOL%in vec4 oe_layer_texcParent;%EOL%in float oe_rex_morphFactor;%EOL%#endif%EOL%%EOL%in vec4 oe_layer_texc;%EOL%%EOL%in float oe_layer_rangeOpacity;%EOL%%EOL%void oe_rexEngine_frag(inout vec4 color)%EOL%{%EOL%    float applyImagery = oe_layer_uid >= 0 ? 1.0 : 0.0;%EOL%    %EOL%	vec4 texelSelf = texture(oe_layer_tex, oe_layer_texc.st);%EOL%%EOL%#ifdef OE_REX_MORPH_IMAGERY%EOL%%EOL%    // sample the parent texture:%EOL%	vec4 texelParent = texture(oe_layer_texParent, oe_layer_texcParent.st);%EOL%%EOL%    // if the parent texture does not exist, use the current texture with alpha=0 as the parent%EOL%    // so we can %QUOTE%fade in%QUOTE% an image layer that starts at LOD > 0:%EOL%    texelParent = mix( vec4(texelSelf.rgb, 0.0), texelParent, oe_layer_texParentExists );%EOL%%EOL%    // Resolve the final texel color:%EOL%	vec4 texel = mix(texelSelf, texelParent, oe_rex_morphFactor);%EOL%%EOL%    // Decide whether to use the texel or the incoming color:%EOL%	texel = mix(color, texel, applyImagery);%EOL%%EOL%#else%EOL%%EOL%    // No morphing, just use the incoming color or texture:%EOL%    vec4 texel = mix(color, texelSelf, applyImagery);%EOL%%EOL%#endif%EOL%%EOL%    // Integrate layer opacity into the texture:%EOL%    texel.a = mix(texel.a, texel.a*oe_layer_opacity*oe_layer_rangeOpacity, applyImagery);%EOL%%EOL%    float firstLayer = (applyImagery == 1.0 && oe_layer_order == 0) ? 1.0 : 0.0;%EOL%%EOL%#ifdef OE_REX_GL_BLENDING%EOL%    %EOL%    // Blend RGB with the incoming color:%EOL%    //color.rgb = texel.rgb*texel.a + color.rgb*(1.0-texel.a);%EOL%%EOL%    // If this is a first image layer, use the max alpha; otherwise just leave it%EOL%    // to GL blending%EOL%    if (firstLayer == 1.0) {%EOL%        color.rgb = texel.rgb*texel.a + color.rgb*(1.0-texel.a);%EOL%        color.a = max(color.a, texel.a);%EOL%    }%EOL%    else color = texel;%EOL%%EOL%#else%EOL%%EOL%    // No blending? The output is just the texel value.%EOL%    color = texel;%EOL%%EOL%#endif%EOL%%EOL%    // disable primary coloring for pick cameras. Necessary to support picking of%EOL%    // draped geometry.%EOL%    float pick = oe_isPickCamera ? 1.0 : 0.0;%EOL%    color = mix(color, vec4(0), pick);%EOL%}%EOL%%EOL%";

    NORMAL_MAP_VERT = "RexEngine.NormalMap.vert.glsl";
    _sources[NORMAL_MAP_VERT] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_normalMapVertex%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%%EOL%uniform mat4 oe_tile_normalTexMatrix;%EOL%%EOL%// stage globals%EOL%vec4 oe_layer_tilec;%EOL%%EOL%out vec2 oe_normalMapCoords;%EOL%out vec3 oe_normalMapBinormal;%EOL%%EOL%void oe_normalMapVertex(inout vec4 unused)%EOL%{%EOL%    // calculate the sampling coordinates for the normal texture%EOL%    oe_normalMapCoords = (oe_tile_normalTexMatrix * oe_layer_tilec).st;%EOL%%EOL%    // send the bi-normal to the fragment shader%EOL%    oe_normalMapBinormal = gl_NormalMatrix * vec3(0,1,0);%EOL%}%EOL%%EOL%";

    NORMAL_MAP_FRAG = "RexEngine.NormalMap.frag.glsl";
    _sources[NORMAL_MAP_FRAG] = "#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_entryPoint oe_normalMapFragment%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.2%EOL%%EOL%// import terrain SDK%EOL%vec4 oe_terrain_getNormalAndCurvature(in vec2);%EOL%%EOL%uniform sampler2D oe_tile_normalTex;%EOL%%EOL%in vec3 vp_Normal;%EOL%in vec3 oe_UpVectorView;%EOL%in vec2 oe_normalMapCoords;%EOL%in vec3 oe_normalMapBinormal;%EOL%%EOL%void oe_normalMapFragment(inout vec4 color)%EOL%{%EOL%    vec4 encodedNormal = oe_terrain_getNormalAndCurvature(oe_normalMapCoords);%EOL%    //vec4 encodedNormal = texture2D(oe_tile_normalTex, oe_normalMapCoords);%EOL%    vec3 normal = normalize(encodedNormal.xyz*2.0-1.0);%EOL%%EOL%    vec3 tangent = normalize(cross(oe_normalMapBinormal, oe_UpVectorView));%EOL%    vp_Normal = normalize( mat3(tangent, oe_normalMapBinormal, oe_UpVectorView) * normal );%EOL%%EOL%    // visualize curvature gradient:%EOL%    //color.rgb = vec3(0,0,0);%EOL%    //color.r = (encodedNormal.a+1.0)/2.0;%EOL%    //color.b = 1.0-color.r;%EOL%%EOL%    // visualize curvature quantized:%EOL%    //if(encodedNormal.a >= 0.4) color.r = 1.0;%EOL%    //if(encodedNormal.a <= -0.4) color.b = 1.0;%EOL%    %EOL%    // visualize normals:%EOL%    //color.rgb = encodedNormal.xyz;%EOL%}%EOL%%EOL%";

    ENGINE_GEOM = "RexEngine.gs.glsl";
    _sources[ENGINE_GEOM] = "#version $GLSL_VERSION_STR%EOL%%EOL%%EOL%#if 0 // currently unused - triangle discard implemented on CPU instead%EOL%%EOL%#pragma vp_name       REX Engine - GS%EOL%#pragma vp_entryPoint oe_rexEngine_gs%EOL%#pragma vp_location   geometry%EOL%%EOL%// Vertex Markers:%EOL%#define MASK_MARKER_DISCARD  0.0%EOL%#define MASK_MARKER_NORMAL   1.0%EOL%#define MASK_MARKER_SKIRT    2.0%EOL%#define MASK_MARKER_BOUNDARY 3.0%EOL%%EOL%layout(triangles)      in;%EOL%layout(triangle_strip) out;%EOL%layout(max_vertices=3) out;%EOL%%EOL%void VP_LoadVertex(in int);%EOL%void VP_EmitModelVertex();%EOL%%EOL%in vec4 oe_layer_tilec;%EOL%%EOL%void oe_rexEngine_gs(void)%EOL%{%EOL%    for(int i=0; i < 3; ++i )%EOL%    {%EOL%        VP_LoadVertex(i);%EOL%        if ( oe_layer_tilec.z == MASK_MARKER_DISCARD )%EOL%            return;%EOL%    }%EOL%%EOL%    for(int i=0; i < 3; ++i )%EOL%    {%EOL%        VP_LoadVertex(i);%EOL%        gl_Position = gl_in[i].gl_Position;%EOL%        VP_EmitModelVertex();%EOL%    }%EOL%    EndPrimitive();%EOL%}%EOL%%EOL%#endif%EOL%%EOL%";

    SDK = "RexEngine.SDK.vert.glsl";
    _sources[SDK] = "#version 330%EOL%#pragma vp_name Rex Terrain SDK%EOL%%EOL%/**%EOL% * SDK functions for the Rex engine.%EOL% * Declare and call these from any shader that runs on the terrain.%EOL% */%EOL%%EOL%// uniforms from terrain engine%EOL%uniform sampler2D oe_tile_elevationTex;%EOL%uniform mat4 oe_tile_elevationTexMatrix;%EOL%uniform vec2 oe_tile_elevTexelCoeff;%EOL%%EOL%uniform sampler2D oe_tile_normalTex;%EOL%uniform mat4 oe_tile_normalTexMatrix;%EOL%%EOL%uniform vec4 oe_tile_key;%EOL%%EOL%// Stage global%EOL%vec4 oe_layer_tilec;%EOL%%EOL%%EOL%/**%EOL% * Sample the elevation data at a UV tile coordinate.%EOL% */%EOL%float oe_terrain_getElevation(in vec2 uv)%EOL%{%EOL%    // Texel-level scale and bias allow us to sample the elevation texture%EOL%    // on texel center instead of edge.%EOL%    vec2 elevc = uv%EOL%        * oe_tile_elevTexelCoeff.x * oe_tile_elevationTexMatrix[0][0]     // scale%EOL%        + oe_tile_elevTexelCoeff.x * oe_tile_elevationTexMatrix[3].st     // bias%EOL%        + oe_tile_elevTexelCoeff.y;                                      %EOL%%EOL%    return texture(oe_tile_elevationTex, elevc).r;%EOL%}%EOL%%EOL%/**%EOL% * Read the elevation at the build-in tile coordinates (convenience)%EOL% */%EOL%float oe_terrain_getElevation()%EOL%{%EOL%    return oe_terrain_getElevation(oe_layer_tilec.st);%EOL%}%EOL%%EOL%/**%EOL% * Read the normal vector and curvature at resolved UV tile coordinates.%EOL% */%EOL%vec4 oe_terrain_getNormalAndCurvature(in vec2 uv_scaledBiased)%EOL%{%EOL%    return texture(oe_tile_normalTex, uv_scaledBiased);%EOL%}%EOL%%EOL%vec4 oe_terrain_getNormalAndCurvature()%EOL%{%EOL%    vec2 uv_scaledBiased = oe_layer_tilec.st * oe_tile_normalTexMatrix[0][0] + oe_tile_normalTexMatrix[3].st;%EOL%    return texture(oe_tile_normalTex, uv_scaledBiased);%EOL%}%EOL%%EOL%/**%EOL% * Scales repeating texture coordinate such that they are [0..1]%EOL% * at a specific reference tile LOD. %EOL% */%EOL%vec2 oe_terrain_scaleCoordsToRefLOD(in vec2 tc, in float refLOD)%EOL%{%EOL%    float dL = oe_tile_key.z - refLOD;%EOL%    float factor = exp2(dL);%EOL%    float invFactor = 1.0/factor;%EOL%    vec2 result = tc * vec2(invFactor);%EOL%%EOL%    vec2 a = floor(oe_tile_key.xy * invFactor);%EOL%    vec2 b = a * factor;%EOL%    vec2 c = b + factor;%EOL%%EOL%    float m = floor(clamp(factor,0.0,1.0)); // if factor>=1.0%EOL%    result += m*(oe_tile_key.xy-b)/(c-b);%EOL%%EOL%    return result;%EOL%}%EOL%%EOL%";
}
